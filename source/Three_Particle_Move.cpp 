
#include "move.h"
#include <gsl/gsl_math.h>


void move::Three_Particle_Move(particles& Particles, box* Box, fileio& Fileio, int mc_time){


	double phi_t;
	double dU_old, dU_new;	
	double delta_U;
	dU_old=0;
	dU_new=0;
	double n1,n2;
	

	id = gsl_rng_uniform_int(r, Box->N);
	doubel phi_t;
 
 	//Check with whom the particle is interacting
	Particles.Collision_List[id].Calculate_OP(Box, id, Particles.N_Particle, Particles.N_Particle[0]->cut_off, Particles.MAX_coll_p);		
	
	int list_j;

	if (Particles.Collision_List[id].Nm >=2){

		dU_old = dU_old + Calculate_Pair_Potential(id, Particles, Box, Particles.Collision_List);

		n1 = Particles.Collision_List[id].Nm;


		
		list_id1 = gsl_rng_uniform_int(Particles.Collision_List[id].Nm);

		do{
			list_id2 = gsl_rng_uniform_int(Particles.Collision_List[id].Nm);

		}while(list_id2==list_id1);	


		Particles.Collision_List[id].Calculate_OP(Box, list_id1, Particles.N_Particle, Particles.N_Particle[0]->cut_off, Particles.MAX_coll_p);		
		dU_old = dU_old + Calculate_Pair_Potential(listid1, Particles, Box, Particles.Collision_List);	

		Particles.Collision_List[id].Calculate_OP(Box, list_id2, Particles.N_Particle, Particles.N_Particle[0]->cut_off, Particles.MAX_coll_p);		
		dU_old = dU_old + Calculate_Pair_Potential(listid2, Particles, Box, Particles.Collision_List);	

		phi_t= (60*M_PI)/180.0;	

		Rot_mat[0] = cos(phi_t);
		Rot_mat[1] = -sin(phi_t);
		Rot_mat[2] = 0;
			
		Rot_mat[3] = sin(phi_t);
		Rot_mat[4] = cos(phi_t);
		Rot_mat[5] = 0;
			
		Rot_mat[6] = 0;
		Rot_mat[7] = 0;
		Rot_mat[8] = 1;
			
		Particles.N_Particle[id]->phi = phi_t;
		Particles.N_Particle[list_id1]->phi = phi_t;
		Particles.N_Particle[list_id2]->phi = phi_t;
		

		if (Particles.N_Particle[id]->phi > 2*M_PI){
			Particles.N_Particle[id]->phi = Particles.N_Particle[id]->phi - 2.0*M_PI;
		}
			
		if (Particles.N_Particle[id]->phi < 0){	
			Particles.N_Particle[id]->phi = Particles.N_Particle[id]->phi + 2.0*M_PI;
		}

		if (Particles.N_Particle[list_id1]->phi > 2*M_PI){
			Particles.N_Particle[list_id1]->phi = Particles.N_Particle[list_id1]->phi - 2.0*M_PI;
		}
			
		if (Particles.N_Particle[list_id1]->phi < 0){	
			Particles.N_Particle[list_id1]->phi = Particles.N_Particle[list_id1]->phi + 2.0*M_PI;
		}


		if (Particles.N_Particle[list_id2]->phi > 2*M_PI){
			Particles.N_Particle[list_id2]->phi = Particles.N_Particle[list_id2]->phi - 2.0*M_PI;
		}
			
		if (Particles.N_Particle[list_id2]->phi < 0){	
			Particles.N_Particle[list_id2]->phi = Particles.N_Particle[list_id2]->phi + 2.0*M_PI;
		}



		Rot_Update_Positions(Particles, id, Rot_mat);
		Particles.N_Particle[id]->Calculate_Axis();
		Particles.N_Particle[id]->Calculate_Patch_Position();

		Rot_Update_Positions(Particles, list_id1, Rot_mat);
		Particles.N_Particle[list_id1]->Calculate_Axis();
		Particles.N_Particle[list_id1]->Calculate_Patch_Position();
		
		Rot_Update_Positions(Particles, list_id2, Rot_mat);
		Particles.N_Particle[list_id2]->Calculate_Axis();
		Particles.N_Particle[list_id2]->Calculate_Patch_Position();


	    Particles.Collision_List[id].Calculate_OP(Box, id, Particles.N_Particle, Particles.N_Particle[0]->cut_off, Particles.MAX_coll_p);
	    Particles.Collision_List[id].Calculate_OP(Box, list_id1, Particles.N_Particle, Particles.N_Particle[0]->cut_off, Particles.MAX_coll_p);
	    Particles.Collision_List[id].Calculate_OP(Box, list_id2, Particles.N_Particle, Particles.N_Particle[0]->cut_off, Particles.MAX_coll_p);
	         
	    exit_status = 0;
		col_count = 0;
		

		Collision_Test( Particles, Box, id, Particles.Collision_List);
		Collision_Test( Particles, Box, list_id1, Particles.Collision_List);
		Collision_Test( Particles, Box, list_id2, Particles.Collision_List);
					
			 
		if(exit_status>=1){
				
			Reset_Positions(Particles, id);	
			Particles.N_Particle[id]->Calculate_Axis();
			Particles.N_Particle[id]->Calculate_Patch_Position();

			Reset_Positions(Particles, list_id1);	
			Particles.N_Particle[list_id1]->Calculate_Axis();
			Particles.N_Particle[list_id1]->Calculate_Patch_Position();

			Reset_Positions(Particles, list_id2);	
			Particles.N_Particle[list_id2]->Calculate_Axis();
			Particles.N_Particle[list_id2]->Calculate_Patch_Position();

			
		}	
					
						
		if (exit_status == 0){
		
			dU_new = dU_new +  Calculate_Pair_Potential(id, Particles, Box, Particles.Collision_List);
		    dU_new = dU_new +  Calculate_Pair_Potential(list_id1, Particles, Box, Particles.Collision_List);
		    dU_new = dU_new +  Calculate_Pair_Potential(list_id2, Particles, Box, Particles.Collision_List);
	 			
			n2 = Particles.Collision_List[id].Nm;


			delta_U = dU_new - dU_old;


			b_factor_pre = ((n1*(n1-1))/(n2*(n2-1)))*exp(-1.0*beta*delta_U);
				

			b_factor = minimum(1,b_factor_pre);
			  
			XI = gsl_rng_uniform(r01);
			  	
			
			// Reject of XI > b_factor

			if (XI > b_factor){

			 	Reset_Positions(Particles, id);	
				Particles.N_Particle[id]->Calculate_Axis();
				Particles.N_Particle[id]->Calculate_Patch_Position();

				Reset_Positions(Particles, list_id1);	
				Particles.N_Particle[list_id1]->Calculate_Axis();
				Particles.N_Particle[list_id1]->Calculate_Patch_Position();

				Reset_Positions(Particles, listid2);	
				Particles.N_Particle[list_id2]->Calculate_Axis();
				Particles.N_Particle[list_id2]->Calculate_Patch_Position();

					
			}

			 	  // Accept move if XI <= b_factor 

			if (XI <= b_factor){
				
				Set_Positions(Particles, id);	
				Set_Positions(Particles, list_id1);	
				Set_Positions(Particles, list_id2);	

				Particles.Total_Energy = Particles.Total_Energy + delta_U;
					
			}


		}
			 
	 
	} 
				
}		